# B-tree란?


B-tree는 Self-balanced Tree 중 가장 유명한 자료구조입니다. Balanced-tree를 의미하며, 이진트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조입니다.

즉, 하나의 노드에 하나의 데이터를 저장하는 다른 Self-Balanced Tree와 달리, 하나의 노드에 여러개의 데이터를 저장하는 방식으로 Tree의 height를 줄여 탐색 시간을 더 획기적으로 줄이도록 고안된 트리입니다.

(B-tree와 B+tree, B*tree가 있지만 일반적으로 B tree라 함은 B-tree를 의미합니다.)

이렇게 고안된 트리를 유지하기 위한 몇가지 규칙이 있습니다.



1. 노드 안에 k개의 데이터가 있다면 자식 노드 수는 k+1개여야 한다.

첫번째 노드의 데이터 갯수를 2개로 잡았다면, 그 자식 노드의 수는 3개여야 합니다.



2. 노드 안 데이터는 정렬되어야 한다.

한 노드 안의 데이터는 오름차순으로 정렬됩니다.



3. 자식 노드의 데이터는 부모 노드의 데이터에 따라 배치된다.

부모 노드의 데이터를 기준으로 자식 노드를 정렬하여 나눕니다.

예시로 1, 2, 3, 4, 5, 6, 7, 8의 값에 대해, 부모 노드의 데이터에 3, 6이 들어간다면


   3  |  6

  /     |      \

1|2     4|5     7|8



과 같은 형태로 자식 노드는 3보다 작은 값, 3과 6 사이의 값, 6보다 큰 값으로 이루어진 3개의 자식 노드가 생깁니다.



4. 루트 노드가 리프 노드가 아닌 경우 항상 2개 이상의 자식을 갖는다.



5. M차 B-tree라면 루트 노드와 리프 노드를 제외하고 최소 M/2개 이상의 데이터를 가지고 있어야 한다.

노드가 가질 수 있는 최대 자식의 수를 M이라 할 때, 이를 M차 B-tree라 합니다.

4차 B-tree에서, 루트와 리프를 제외한 노드 각각의 데이터는 최소 2개여야 한다는 의미입니다.



 6. 모든 리프 노드의 높이는 같아야 한다.



7. 리프 노드의 데이터 수는 M보다 작아야 한다.

4차 B-tree에서, 리프 노드에 들어가는 데이터 수는 3 이하여야 한다는 의미입니다.





# B*tree란?


B*tree는 균형을 유지하기 위한 연산에서 노드의 생성과 부가적인 연산을 최소화하기 위해 등장하게 되었습니다.
기존 B-tree에서 자식 노드가 최소 M/2개의 데이터를 가져야 했던 점이 M*2/3개로 바뀌었고, 노드가 가득 찼을 때 분열하지 않고 형제 노드로 재배치를 하게 된다는 차이점이 있습니다.



# B+tree란?


B+Tree는 B-Tree의 확장 개념입니다. B-Tree의 경우 중간 노드들의 데이터에 key와 value를 담을 수 있지만, B+tree의 경우 중간 노드에는 key만 두고, value는 담지 않습니다. 오직 리프 노드에만 key와 data를 저장하고, 리프 노드끼리는 Linked list로 연결되는 방식입니다. 이러한 방식의 장점은 리프 노드를 제외하면 value를 담지 않기에 메모리를 더 확보할 수 있습니다. 또한 트리의 높이 또한 낮아지게 되며, 탐색 시 리프 노드의 데이터만 살피므로 B-Tree보다 탐색에 매우 유리합니다.